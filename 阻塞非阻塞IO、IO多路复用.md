### IO多路复用、同步和异步（调用层面）、阻塞和非阻塞（线程和进程层面）（重点）

**同步过程中：**
执行一个操作之后，进程触发IO操作并等待(也就是我们说的阻塞)或者轮询的去查看IO操作(也就是我们说的非阻塞)是否完成，等待结果，然后才继续执行后续的操作。

** 异步过程中：**
进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成异步一定是非阻塞的！！！
**因此同步和异步针对应用程序来说，关注的是程序中间的协作关系、阻塞和非阻塞关注的是单个进程的执行状态。**
|同步|异步|阻塞|非阻塞|
|:--:|:--:|:--:|:--:|
|提交完任务之后，要么等，要么过一段时间来问，总之IO不结束就不继续下面的动作| 提交完任务之后就不管了，等通知才回来执行刚才没做完的操作。|后两种关注的是单个进程/线程的执行状态，概念上和同步异步差不多。|同前|

### 阻塞 ?
(1)非阻塞忙轮询：数据没来，进程就不停的去检测数据，直到数据来。
(2)阻塞：数据没来，啥都不做，直到数据来了，才进行下一步的处理。

非阻塞轮询伪代码：
```java
while true {
	for i in stream[] {
		if i has data
			read until unavailable
	}
}
```
#### 代理select和epoll（event poll）的区别：
select只是告诉我们一定数目的流有事件了，至于哪个流有事件，还得我们一个一个轮询；
而epoll（每个事件都关联上fd-文件描述符）会把发生的事件告诉你，通过发生的事件就自然而然定位到哪个流了。--->因此是一种空间换时间的做法。

#### 输入操作一般包含两个步骤：
（1）对一个套接口上的操作，先是数据从网络到达，并将其复制到内核的某个缓冲区；
（2）再将数据从内核缓冲区复制到进程缓冲区。

### 阻塞IO：（block IO）
最广泛的模型是阻塞I/O模型，默认情况下，所有套接口都是阻塞的。以read操作为例：
（1）进程发起read，进行recvfrom系统调用 --》
（2）内核开始第一阶段--准备数据（从磁盘拷贝到缓冲区），进程请求的数据并不是一下就能准备好，准备数据是要消耗时间的。--》
（3）**与此同时，进程阻塞，等待数据**--》 *（主要就是这里等着内核准备数据完毕为止，所以是阻塞的）*
（4）直到数据从内核拷贝到了用户空间，内核返回结果，解除阻塞。
也就是说，内核准备数据和数据从内核拷贝到进程内存地址这两个过程都是阻塞的。

### 非阻塞IO：（no-block IO）
（1）当用户进程发起read操作时，如果内核中的数据还没有准备好--》
（2）那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度来说，它发起一个read之后并不需要等待，而是马上就得到了一个结果--》
（3）用户进程得到一个error之后就知道数据还没准备好，于是它可以再次发送read。一旦内核中数据准备好了，并且又再次收到了用户进程的system call--》
（4）那么它马上就可以将数据拷贝到用户内存，然后返回。
所以非阻塞IO的特点就是用户进程在内核准备数据的阶段**需要不断地主动询问：数据好了没？？？**

### IO多路复用：用select、poll、epoll监听多个io对象，当io对象有变化（有数据）时就通知用户进程。好处是单个进程可以处理多个socket。
（1）当用户进程调用了select，那么整个进程会被block --》 
（2）而同时，内核会监视所有select负责地socket --》
（3）当任何一个socket中的数据准备好了，select就可以返回--》
（4）这个时候用户进程再次调用read操作，将数据从内核拷贝到用户进程。

如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用多线程 + 阻塞 IO的web server性能更好，可能延迟还更大。
select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接（因为它可以同时监听多个IO对象）。
*在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。*

### 异步IO(asynchronous IO) 一定是非阻塞IO（但是它不是轮询地去问，而是等通知）
（1）用户进程发起read之后，就可以了立刻去做其他的事情--》
（2）另一方面，内核收到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block--》
（3）然后，内核会等到数据准备完成，然后将数据拷贝到用户内存，当一切都完成之后，内核会给用户进程发送一个signal，告诉他read操作完成了--》
（4）用户进程再切回来继续做剩下地事情。

#### 图示
（1）同步阻塞IO--发起IO请求时不能做任何事情，cpu资源利用率不够。
[!!! 同步阻塞IO](https://images0.cnblogs.com/blog/405877/201411/142330286789443.png)
（2）同步非阻塞IO--需要不断发送read，无端消耗cpu
[!!! 同步非阻塞IO](https://images0.cnblogs.com/blog/405877/201411/142332004602984.png)
（3）IO多路复用--有数据是socket被激活，select函数返回，发送read请求
[!!! IO多路复用](https://images0.cnblogs.com/blog/405877/201411/142332187256396.png)
与同步IO的比较：
从流程上来看，使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。***但是，使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可达到在同一个线程内同时处理多个IO请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。***

### IO多路复用模式采用了Reactor设计模式，核心是EventHandler。Reactor类用于管理EventHandler（注册、删除等），并使用handle_events实现事件循环，不断调用同步事件多路分离器（一般是内核）的多路分离函数select，只要某个文件句柄被激活（可读/写等），select就返回（阻塞），handle_events就会调用与文件句柄关联的事件处理器的handle_event进行相关操作。
[! 基于Reactor设计模式的IO多路复用](https://images0.cnblogs.com/blog/405877/201411/142333254136604.png)
